#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "driver/adc.h"
#include "driver/twai.h"
#define PIN_EN      GPIO_NUM_NC      // EN (enable/reset)
#define PIN_BOOT    GPIO_NUM_0        // BOOT

#define PIN_CAN_RX  GPIO_NUM_10       // CAN_RX (IO10 on ESP32-C6)
#define PIN_CAN_TX  GPIO_NUM_11       // CAN_TX (IO11 on ESP32-C6)

// Shift reg
#define PIN_SR_CLK    GPIO_NUM_4    
#define PIN_SR_DATA   GPIO_NUM_7
#define PIN_SR_LATCH1 GPIO_NUM_5
#define PIN_SR_LATCH2 GPIO_NUM_6


#define PIN_GPIO1   GPIO_NUM_8        
#define PIN_GPIO2   GPIO_NUM_9        
#define PIN_GPIO3   GPIO_NUM_15       
#define PIN_GPIO4   GPIO_NUM_16       
#define PIN_GPIO5   GPIO_NUM_17       
#define PIN_GPIO6   GPIO_NUM_18       
#define PIN_GPIO7   GPIO_NUM_19       
#define PIN_GPIO8   GPIO_NUM_20       
#define PIN_GPIO9   GPIO_NUM_21       
#define PIN_GPIO10  GPIO_NUM_22       
#define PIN_GPIO11  GPIO_NUM_23       

// Analog input
#define PIN_A0     GPIO_NUM_0        
#define PIN_A1     GPIO_NUM_1        
#define PIN_A2     GPIO_NUM_2        
#define PIN_I_MON  GPIO_NUM_3        

// User LED
#define PIN_USR_LED GPIO_NUM_15      

// USB
#define PIN_USB_DN GPIO_NUM_12      
#define PIN_USB_DP GPIO_NUM_13      

// Shift reg states
static uint8_t seg_reg_state = 0xFF;  
static uint8_t out_reg_state = 0x00;  

// 7-szegmens
static const uint8_t SevenSegPatterns[11] = {
    0b11000000, 0b11111001, 0b10100100, 0b10110000, 0b10011001,
    0b10010010, 0b10000010, 0b11111000, 0b10000000, 0b10010000,
    0b11111111
};

// Shift reg fgv
static void shiftOut16(uint16_t combined_value, bool latch1, bool latch2) {
    for (int i = 15; i >= 0; --i) {
        uint8_t bit_val = (combined_value >> i) & 0x1;
        gpio_set_level(PIN_SR_DATA, bit_val);
        gpio_set_level(PIN_SR_CLK, 1);
        gpio_set_level(PIN_SR_CLK, 0);
    }
    if (latch1) { gpio_set_level(PIN_SR_LATCH1, 1); gpio_set_level(PIN_SR_LATCH1, 0); }
    if (latch2) { gpio_set_level(PIN_SR_LATCH2, 1); gpio_set_level(PIN_SR_LATCH2, 0); }
}

// 7-szegmens fgv
void SevenSegment(int number) {
    if (number < 0 || number > 10) return;
    seg_reg_state = SevenSegPatterns[number];
    uint16_t combined = ((uint16_t)seg_reg_state << 8) | out_reg_state;
    shiftOut16(combined, false, true);
}

// Digit output control fgv
void Out(int channel, bool state) {
    if (channel < 0 || channel > 6) return;
    uint8_t mask = 1 << channel;
    if (state) { out_reg_state |= mask; } else { out_reg_state &= ~mask; }
    uint16_t combined = ((uint16_t)seg_reg_state << 8) | out_reg_state;
    shiftOut16(combined, true, false);
}

// User LED control
void UsrLed(bool state) {
    gpio_set_level(PIN_USR_LED, state ? 0 : 1);
}

#include "driver/twai.h"

void CAN_Init() {
    twai_general_config_t g_config = TWAI_GENERAL_CONFIG_DEFAULT(PIN_CAN_TX, PIN_CAN_RX, TWAI_MODE_NORMAL);
    g_config.tx_queue_len = 10;
    g_config.rx_queue_len = 10;
    twai_timing_config_t t_config = TWAI_TIMING_CONFIG_500KBITS();
    twai_filter_config_t f_config = TWAI_FILTER_CONFIG_ACCEPT_ALL();
    if (twai_driver_install(&g_config, &t_config, &f_config) == ESP_OK) twai_start();
}

// CAN message trans
void CAN_SendExample(uint16_t adc_value) {
    twai_message_t msg = { .identifier = 0x101, .extd = 0, .rtr = 0, .data_length_code = 2, .data = {adc_value & 0xFF, (adc_value >> 8) & 0xFF} };
    twai_transmit(&msg, pdMS_TO_TICKS(100));
}

// CAN message reception
void CAN_ReceiveExample() {
    twai_message_t rx_msg;
    if (twai_receive(&rx_msg, 0) == ESP_OK) {
        if (rx_msg.identifier == 0x200 && rx_msg.data_length_code > 0) Out(rx_msg.data[0], rx_msg.data[1] != 0);
    }
}

#define BOARD_ID  1

void app_main(void) {
    gpio_set_direction(PIN_USR_LED, GPIO_MODE_OUTPUT);
    gpio_set_direction(PIN_SR_CLK, GPIO_MODE_OUTPUT);
    gpio_set_direction(PIN_SR_DATA, GPIO_MODE_OUTPUT);
    gpio_set_direction(PIN_SR_LATCH1, GPIO_MODE_OUTPUT);
    gpio_set_direction(PIN_SR_LATCH2, GPIO_MODE_OUTPUT);
    gpio_set_direction(PIN_BOOT, GPIO_MODE_INPUT);
    gpio_pullup_en(PIN_BOOT);
    adc1_config_width(ADC_WIDTH_BIT_12);
    adc1_config_channel_atten(ADC1_CHANNEL_0, ADC_ATTEN_DB_11);
    adc1_config_channel_atten(ADC1_CHANNEL_1, ADC_ATTEN_DB_11);
    adc1_config_channel_atten(ADC1_CHANNEL_2, ADC_ATTEN_DB_11);
    shiftOut16(((uint16_t)SevenSegPatterns[10] << 8) | 0x00, true, true);
    CAN_Init();
    const TickType_t led_toggle_interval = pdMS_TO_TICKS(500);
    TickType_t last_wake = xTaskGetTickCount();
    bool led_state = false;
    SevenSegment(BOARD_ID);
    while (1) {
        led_state = !led_state;
        UsrLed(led_state);
        int adc0 = adc1_get_raw(ADC1_CHANNEL_0);
        CAN_SendExample(adc0);
        CAN_ReceiveExample();
        vTaskDelayUntil(&last_wake, led_toggle_interval);
    }
}
